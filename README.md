# WireGuard Telegram Bot with Subscription System

Telegram-бот для управления WireGuard VPN с системой подписок, ручной оплатой и административным одобрением платежей.

## Описание проекта

Бот предоставляет пользователям возможность:
- Оформлять подписку на WireGuard VPN (30/90/180 дней)
- Выбирать количество устройств (1-5)
- Оплачивать подписку через единый статический QR-код
- Получать WireGuard конфигурации для своих устройств
- Управлять устройствами через Telegram интерфейс

Администраторы могут:
- Просматривать все платежи на проверке
- Одобрять/отклонять платежи с проверкой суммы и комментария
- Автоматически получать уведомления о новых платежах

## Архитектура

### Stage 1 (MVP) - Текущая реализация

Все компоненты на одном сервере:
- **Telegram Bot** (`internal/telegram`) - обработка команд и callback'ов
- **Billing Service** (`internal/billing`) - управление платежами и подписками
- **Access Service** (`internal/access`) - проверка прав доступа
- **Storage** (`internal/storage`) - SQLite база данных
- **Local Provisioner** (`internal/provisioning/local`) - локальное управление WireGuard через `wgctrl`
- **Scheduler** (`internal/scheduler`) - фоновые задачи (обновление статусов, уведомления)

**Provisioner Interface:**
- Абстракция для управления WireGuard устройствами
- `LocalProvisioner` - локальное управление (Stage 1, НЕ для продакшена)
- `SSHProvisioner` - удаленное управление через SSH (Stage 2, продакшен)
- `DevProvisioner` - мок для разработки (DEV_MODE=true)

### Stage 2 (RU → DE via SSH)

Разделение на два сервера:
- **RU сервер**: Telegram Bot, SQLite DB, Billing, Access Control, Scheduler
  - НЕ содержит WireGuard интерфейса (wg1)
  - Управляет DE сервером ТОЛЬКО по SSH
- **DE сервер**: WireGuard (wg1)
  - Все peers и IP адреса живут ТОЛЬКО здесь
  - Управляется с RU сервера через SSH
  - **Важно:** wg1 используется только Telegram-ботом, wg0 не затрагивается
- **Связь**: SSH с allow-listed командой `/usr/local/bin/wg-provision`
- **Provisioner**: `SSHProvisioner` (вместо `LocalProvisioner`)

**Переключение на Stage 2:**
Установите переменную окружения `SSH_WG_ENABLED=true` в `.env` файле на RU сервере.

**Важно:**
- RU сервер никогда не фигурирует в конфиге клиента
- WireGuard endpoint для клиентов ВСЕГДА DE сервер
- Никакого локального wg на RU сервере

## Пользовательский Flow

### 1. Создание платежа

1. Пользователь отправляет `/start` или `/menu`
2. Выбирает "Оплата/Продление"
3. Выбирает срок подписки (30/90/180 дней)
4. Выбирает количество устройств (1-5)
5. Система:
   - Рассчитывает цену: `device_count * 100 RUB * multiplier` (30=1.0, 90=0.95, 180=0.90)
   - Генерирует уникальный `reference_code` (алфавитно-цифровой)
   - Генерирует уникальный `payment_comment` (2-3 нейтральных русских слова + суффикс)
6. Пользователь видит:
   - Статический QR-код (одинаковый для всех)
   - Сумму к оплате
   - Код заявки (`reference_code`)
   - **Комментарий к переводу** (`payment_comment`) - обязателен для указания

### 2. Загрузка подтверждения оплаты

1. Пользователь оплачивает перевод со **строго указанным комментарием**
2. Отправляет `/payment` или "Я оплатил" в меню
3. Загружает фото/документ со скриншотом платежа
4. Система:
   - Прикрепляет proof к payment
   - Меняет статус на `pending_review`
   - Отправляет уведомление администратору (если настроено)

### 3. Активация подписки

1. Администратор просматривает `/admin` - список платежей на проверке
2. Открывает детали платежа:
   - Проверяет сумму
   - Проверяет комментарий к переводу (должен совпадать с ожидаемым)
   - Просматривает uploaded proof
3. При одобрении система:
   - Проверяет совпадение `payment_comment` (строго обязательно)
   - Проверяет наличие proof
   - Создает новую подписку ИЛИ продлевает существующую
   - Меняет статус payment на `approved`
   - Уведомляет пользователя

### 4. Создание устройства

1. Пользователь отправляет `/newkeys` или `/pubkey`
2. Система проверяет через `access.CanProvisionDevice()`:
   - Есть ли активная подписка
   - Не истекла ли подписка
   - Не превышен ли лимит устройств
3. Если проверка пройдена:
   - Генерируются ключи (или используется переданный public key)
   - **Атомарно** выделяется IP адрес через DB транзакцию
   - Создается peer на WireGuard интерфейсе
   - Генерируется клиентский конфиг
   - Создается QR-код
   - Устройство сохраняется в БД
4. Пользователь получает конфиг и QR-код

## Admin Flow

### Команды администратора

- `/admin` - главное меню администратора:
  - Список платежей со статусом `pending_review`
  - Кнопка "Обновить" для обновления списка

### Просмотр деталей платежа

1. Администратор выбирает платеж из списка
2. Видит:
   - ID платежа
   - Пользователь (Telegram username)
   - Срок подписки (дни)
   - Количество устройств
   - Сумма к оплате
   - Код заявки (`reference_code`)
   - **Ожидаемый комментарий к переводу** (`payment_comment`)
   - Статус платежа
   - Скриншот подтверждения (если загружен)

### Одобрение платежа

1. Администратор нажимает "✅ Проверить и одобрить"
2. Система показывает ожидаемый комментарий
3. Администратор может:
   - Ввести комментарий из скриншота для проверки
   - Одобрить с предустановленным комментарием (если совпадает)
4. Система проверяет:
   - **Совпадение `payment_comment`** (строго обязательно)
   - Наличие `proof_file_id`
   - Если проверка не прошла - ошибка, платеж не одобряется
5. При успешной проверке:
   - Создается/продлевается подписка
   - Пользователь получает уведомление
   - Платеж помечается как `approved`

### Отклонение платежа

1. Администратор нажимает "❌ Отклонить"
2. Указывает причину отклонения
3. Платеж помечается как `rejected`
4. Пользователь получает уведомление с причиной

## Жизненный цикл подписки

### Статусы подписки

- **active** - активная подписка
- **expiring** - за 3 дня до окончания (уведомление отправлено)
- **paused** - подписка закончилась, grace period (3 дня)
- **expired** - подписка полностью истекла, устройства будут отозваны

### Автоматические действия (Scheduler)

**Ежедневно в полночь:**

1. **Обновление статусов подписок:**
   - `active` → `expiring` (за 3 дня до окончания)
   - `expiring` → `paused` (при `ends_at`)
   - `paused` → `expired` (при `grace_period_ends_at`)

2. **Отправка уведомлений:**
   - За 3 дня до окончания: "Подписка скоро истечет"
   - При переходе в `paused`: "Подписка приостановлена, у вас 3 дня для продления"

3. **Отзыв устройств:**
   - Через 30 дней после `grace_period_ends_at`: удаление peer'ов из WireGuard
   - Данные устройств сохраняются в БД еще 30 дней для восстановления

## Установка

### Требования

- Go 1.16+
- SQLite3 (для Stage 1) или PostgreSQL (для Stage 2)
- WireGuard и wireguard-tools
- Telegram Bot Token (от @BotFather)

### Шаг 1: Клонирование репозитория

```bash
git clone <repository-url>
cd wireguard-telegram-bot-dev
```

### Шаг 2: Установка зависимостей

```bash
go mod download
```

### Шаг 3: Выбор режима работы

#### Stage 1 (LocalProvisioner) - НЕ для продакшена

1. Установите WireGuard и wireguard-tools на сервере
2. Создайте серверный конфиг (например, `/etc/wireguard/wg1.conf`)
3. Запустите WireGuard интерфейс:
   ```bash
   sudo wg-quick up wg1
   ```

**Важно:** Stage 1 предназначен только для разработки. Для продакшена используйте Stage 2.

#### Stage 2 (SSHProvisioner) - Продакшен

**RU сервер:**
- НЕ требует установки WireGuard
- НЕ требует интерфейса wg1
- Требует SSH доступ к DE серверу
- Использует SQLite БД

**DE сервер:**
- Требует установки WireGuard и wireguard-tools
- Требует интерфейса wg1 (используется только Telegram-ботом)
- **Важно:** Интерфейс wg0 не затрагивается и может существовать параллельно
- Требует установки скрипта `/usr/local/bin/wg-provision` (см. ниже)
- Должен быть доступен по SSH с RU сервера

**Установка wg-provision на DE сервере:**

Скрипт `/usr/local/bin/wg-provision` должен поддерживать команды:

**CREATE:**
```bash
wg-provision create \
  --user-id <int> \
  --subscription-id <int> \
  --device-name "<string>" \
  --public-key "<string>"
```

**RESPONSE (JSON):**
```json
{
  "assigned_ip": "10.66.66.10/32",
  "server_public_key": "<pubkey>",
  "endpoint": "<DE_IP>:51820",
  "dns": "8.8.8.8"
}
```

**Важно:**
- DE сервер возвращает только данные, НЕ генерирует client_config
- RU сервер генерирует client_config самостоятельно используя шаблоны
- assigned_ip - единственный источник истины (выделяется на DE сервере)

**REVOKE:**
```bash
wg-provision revoke --assigned-ip "<ip>"
```

**RESPONSE (JSON):**
```json
{ "ok": true }
```

### Шаг 4: Настройка переменных окружения

```bash
cp .env.example .env
# Отредактируйте .env файл
```

#### Stage 1 (LocalProvisioner) - переменные окружения:

Обязательные переменные:
- `TELEGRAM_APITOKEN` - токен бота от @BotFather
- `STATIC_QR_CODE` - статический QR-код для оплаты (текст или URL)
- `WIREGUARD_INTERFACE` - имя интерфейса WireGuard (например, `wg1`)
- `SERVER_ENDPOINT` - внешний IP:порт сервера (например, `123.45.67.89:51820`)
- `DNS_IPS` - DNS серверы через запятую (например, `8.8.8.8,8.8.4.4`)

Опциональные:
- `ADMIN_USERNAMES` - Telegram username'ы администраторов через запятую
- `DATABASE_DSN` - путь к SQLite файлу (по умолчанию `bot.db`)
- `DEV_MODE` - `true` для тестирования без реального WireGuard

#### Stage 2 (SSHProvisioner) - переменные окружения:

**На RU сервере:**

Обязательные переменные:
- `TELEGRAM_APITOKEN` - токен бота от @BotFather
- `STATIC_QR_CODE` - статический QR-код для оплаты (текст или URL)
- `SSH_WG_ENABLED=true` - включить SSH provisioning
- `SSH_WG_HOST` - IP или hostname DE сервера (например, `10.0.0.2` или `de-server.example.com`)
- `SSH_WG_PORT` - SSH порт DE сервера (по умолчанию `22`)
- `SSH_WG_USER` - SSH username для подключения к DE серверу
- `SSH_WG_KEY_PATH` - путь к SSH приватному ключу для подключения к DE серверу

Опциональные:
- `ADMIN_USERNAMES` - Telegram username'ы администраторов через запятую
- `DATABASE_DSN` - путь к SQLite файлу (по умолчанию `bot.db`)

**Важно:**
- RU сервер НЕ требует `WIREGUARD_INTERFACE`, `SERVER_ENDPOINT`, `DNS_IPS` (они нужны только для Stage 1)
- `SERVER_ENDPOINT` в клиентском конфиге берется из ответа DE сервера (поле `endpoint`)
- Client config генерируется на RU сервере используя шаблоны из данных DE сервера

**Пример .env для Stage 2 (RU сервер):**
```bash
TELEGRAM_APITOKEN=your_bot_token
STATIC_QR_CODE=your_static_qr_code
SSH_WG_ENABLED=true
# Telegram
TELEGRAM_APITOKEN=your_bot_token
ADMIN_USERNAMES=admin1,admin2

# Mode
DEV_MODE=false
SSH_WG_ENABLED=true

# SSH to DE server
SSH_WG_HOST=10.0.0.2
SSH_WG_PORT=22
SSH_WG_USER=wgadmin
SSH_WG_KEY_PATH=/root/.ssh/wg_de_ed25519

# Database
DATABASE_DSN=bot.db

# Payments
STATIC_QR_CODE=your_static_qr_code
# или PAYMENT_QR_PATH=assets/payment_qr.png
```

**Важно для безопасности:**
- SSH ключ должен иметь правильные права доступа: `chmod 600 /path/to/ssh/private/key`
- SSH ключ НЕ должен иметь пароль (или используйте ssh-agent)
- На DE сервере должен быть настроен allow-listed доступ только для команды `/usr/local/bin/wg-provision`
- НЕ храните SSH ключи в коде или репозитории

### Шаг 5: Запуск

```bash
# Обычный запуск
go run cmd/bot/main.go

# Или соберите бинарник
go build -o wireguard-bot cmd/bot/main.go
sudo ./wireguard-bot
```

**Важно для Stage 1:** Для работы с WireGuard интерфейсом требуются права root (или CAP_NET_ADMIN).

**Важно для Stage 2:** RU сервер НЕ требует WireGuard интерфейса и НЕ требует root прав для WireGuard. Проект должен успешно компилироваться и запускаться без wg на RU сервере.

## Тестовый сценарий

### Проверка базовой функциональности

1. **Создание пользователя:**
   ```
   /start
   ```
   - Пользователь должен быть создан в БД

2. **Создание платежа:**
   ```
   /menu → "Оплата/Продление" → 30 дней → 1 устройство
   ```
   - Должен быть создан payment со статусом `created`
   - Должен быть показан статический QR
   - Должен быть показан `reference_code`
   - Должен быть показан `payment_comment` с предупреждением

3. **Загрузка proof:**
   ```
   /payment → загрузить фото/документ
   ```
   - Payment должен перейти в статус `pending_review`
   - Должно быть прикреплено `proof_file_id`

4. **Admin approval (от админа):**
   ```
   /admin → выбрать платеж → "✅ Проверить и одобрить"
   ```
   - Ввести правильный `payment_comment`
   - Платеж должен быть одобрен
   - Подписка должна быть создана

5. **Создание устройства:**
   ```
   /newkeys
   ```
   - Должен быть проверен доступ (active subscription)
   - Должен быть создан peer в WireGuard
   - Должен быть выделен IP адрес
   - Должен быть возвращен конфиг и QR

### Проверка отклонения платежа

1. Создать платеж с неправильным комментарием
2. Администратор пытается одобрить с неправильным комментарием
3. Система должна вернуть ошибку
4. Платеж должен остаться в статусе `pending_review`

### Проверка лимита устройств

1. Создать подписку на 2 устройства
2. Создать 2 устройства через `/newkeys`
3. Попытка создать 3-е устройство должна вернуть ошибку "лимит устройств достигнут"

## Важные ограничения

### ⚠️ Критически важно

1. **Один статический QR-код:**
   - Одинаковый для всех пользователей
   - Не содержит метаданных
   - Настраивается через `STATIC_QR_CODE`

2. **Ручное одобрение платежей:**
   - Все платежи требуют admin approval
   - Автоматическая активация **запрещена**
   - Scheduler НЕ может активировать подписки

3. **Обязательный payment comment:**
   - Каждый платеж получает уникальный нейтральный комментарий
   - Комментарий генерируется автоматически (2-3 русских слова + суффикс)
   - Пользователь ОБЯЗАН указать этот комментарий при переводе
   - Платеж без правильного комментария **НЕ будет одобрен**

4. **Запрет provisioning без подписки:**
   - `/newkeys` и `/pubkey` доступны только при активной подписке
   - Проверка через `access.CanProvisionDevice()`
   - Лимит устройств строго соблюдается

### Дополнительные правила

- **IP выделение:** атомарное через DB транзакцию, без гонок
- **Grace period:** 3 дня после окончания подписки
- **Data retention:** устройства сохраняются 30 дней после expire
- **Subscription extension:** продлевается от текущей даты окончания
- **Price calculation:** `device_count * 100 RUB * multiplier` (30=1.0, 90=0.95, 180=0.90)

## Структура проекта

```
.
├── cmd/
│   └── bot/
│       └── main.go              # Точка входа
├── internal/
│   ├── telegram/                # Telegram бот (handlers, keyboards, commands)
│   ├── storage/                 # БД (models, migrations, repository)
│   ├── billing/                 # Платежи и подписки (billing, comment)
│   ├── access/                  # Проверка прав доступа
│   ├── scheduler/               # Фоновые задачи
│   ├── provisioning/            # Абстракция provisioning (interface, local, ssh)
│   └── wireguard/               # Обертка над Provisioner (interface, dev)
└── README.md
```

## Технические детали

### База данных

**SQLite (Stage 1):**
- Таблицы: `users`, `payments`, `subscriptions`, `devices`
- Миграции выполняются автоматически при старте
- Транзакции для атомарности IP выделения

**PostgreSQL (Stage 2, планируется):**
- Поддержка через изменение `DATABASE_DSN`

### Provisioning

**Stage 1 - LocalProvisioner:**
- Управление через `wgctrl` (локальный WireGuard интерфейс на том же сервере)
- Атомарное выделение IP через DB транзакцию
- Автоматическая генерация ключей и конфигов
- **НЕ для продакшена** - используется только для разработки

**Stage 2 - SSHProvisioner (продакшен):**
- Удаленное управление через SSH (RU сервер → DE сервер)
- Allow-listed команда: ТОЛЬКО `/usr/local/bin/wg-provision`
- Machine-readable JSON output от DE сервера
- Ключи генерируются на RU сервере
- **DE сервер - единственный источник истины по assigned_ip** (RU НЕ резервирует IP)
- Peer создается на DE сервере через SSH команду `wg-provision create`
- Клиентский конфиг генерируется на RU сервере используя шаблоны и данные из JSON ответа DE сервера
- Endpoint в клиентском конфиге ВСЕГДА DE сервер (никогда RU сервер)

**Переключение режимов:**
- `DEV_MODE=true` → DevProvisioner (тестирование)
- `SSH_WG_ENABLED=true` → SSHProvisioner (Stage 2, продакшен)
- иначе → LocalProvisioner (Stage 1, разработка, НЕ продакшен)

### Безопасность

- Все SQL-запросы используют prepared statements
- Транзакции для критичных операций
- Проверка прав доступа на каждом шаге
- Admin-only команды защищены проверкой `isAdmin()`

## Troubleshooting

### Бот не запускается

- Проверьте `TELEGRAM_APITOKEN`
- Проверьте права доступа к WireGuard интерфейсу (нужен root)
- Проверьте `WIREGUARD_INTERFACE` - интерфейс должен существовать

### Платежи не одобряются

- Убедитесь, что `payment_comment` совпадает точно (case-sensitive)
- Проверьте, что proof загружен
- Проверьте логи бота

### Устройства не создаются

- Проверьте активность подписки через `/menu`
- Проверьте лимит устройств
- Проверьте логи WireGuard: `sudo wg show`

## Лицензия

[Указать лицензию, если есть]

## Авторы

[Указать авторов]
