# WireGuard Telegram Bot with Subscription System

Telegram-бот для управления WireGuard VPN с системой подписок, ручной оплатой и административным одобрением платежей.

## Описание проекта

Бот предоставляет пользователям возможность:
- Оформлять подписку на WireGuard VPN (30/90/180 дней)
- Выбирать количество устройств (1-5)
- Оплачивать подписку через единый статический QR-код
- Получать WireGuard конфигурации для своих устройств
- Управлять устройствами через Telegram интерфейс

Администраторы могут:
- Просматривать все платежи на проверке
- Одобрять/отклонять платежи с проверкой суммы и комментария
- Автоматически получать уведомления о новых платежах

## Архитектура

Односерверная архитектура - все компоненты работают на одном сервере с WireGuard:

- **Telegram Bot** (`internal/telegram`) - обработка команд и callback'ов
- **Billing Service** (`internal/billing`) - управление платежами и подписками
- **Access Service** (`internal/access`) - проверка прав доступа
- **Storage** (`internal/storage`) - SQLite база данных
- **Local Provisioner** (`internal/provisioning/local`) - локальное управление WireGuard через `wgctrl`
- **Scheduler** (`internal/scheduler`) - фоновые задачи (обновление статусов, уведомления)

**Provisioner Interface:**
- Абстракция для управления WireGuard устройствами
- `LocalProvisioner` - локальное управление WireGuard через `wgctrl` (production)
- `DevProvisioner` - мок для разработки/тестирования (DEV_MODE=true)

**Важно:**
- Telegram бот и WireGuard работают на одном сервере
- WireGuard интерфейс `wg1` используется только Telegram-ботом
- Интерфейс `wg0` не затрагивается и может существовать параллельно
- Все peers и IP адреса управляются локально через `wgctrl`

## Пользовательский Flow

### 1. Создание платежа

1. Пользователь отправляет `/start` или `/menu`
2. Выбирает "Оплата/Продление"
3. Выбирает срок подписки (30/90/180 дней)
4. Выбирает количество устройств (1-5)
5. Система:
   - Рассчитывает цену: `device_count * 100 RUB * multiplier` (30=1.0, 90=0.95, 180=0.90)
   - Генерирует уникальный `reference_code` (алфавитно-цифровой)
   - Генерирует уникальный `payment_comment` (2-3 нейтральных русских слова + суффикс)
6. Пользователь видит:
   - Статический QR-код (одинаковый для всех)
   - Сумму к оплате
   - Код заявки (`reference_code`)
   - **Комментарий к переводу** (`payment_comment`) - обязателен для указания

### 2. Загрузка подтверждения оплаты

1. Пользователь оплачивает перевод со **строго указанным комментарием**
2. Отправляет `/payment` или "Я оплатил" в меню
3. Загружает фото/документ со скриншотом платежа
4. Система:
   - Прикрепляет proof к payment
   - Меняет статус на `pending_review`
   - Отправляет уведомление администратору (если настроено)

### 3. Активация подписки

1. Администратор просматривает `/admin` - список платежей на проверке
2. Открывает детали платежа:
   - Проверяет сумму
   - Проверяет комментарий к переводу (должен совпадать с ожидаемым)
   - Просматривает uploaded proof
3. При одобрении система:
   - Проверяет совпадение `payment_comment` (строго обязательно)
   - Проверяет наличие proof
   - Создает новую подписку ИЛИ продлевает существующую
   - Меняет статус payment на `approved`
   - Уведомляет пользователя

### 4. Создание устройства

1. Пользователь отправляет `/newkeys` или `/pubkey`
2. Система проверяет через `access.CanProvisionDevice()`:
   - Есть ли активная подписка
   - Не истекла ли подписка
   - Не превышен ли лимит устройств
3. Если проверка пройдена:
   - Генерируются ключи (или используется переданный public key)
   - **Атомарно** выделяется IP адрес через DB транзакцию
   - Создается peer на WireGuard интерфейсе
   - Генерируется клиентский конфиг
   - Создается QR-код
   - Устройство сохраняется в БД
4. Пользователь получает конфиг и QR-код

## Admin Flow

### Команды администратора

- `/admin` - главное меню администратора:
  - Список платежей со статусом `pending_review`
  - Кнопка "Обновить" для обновления списка

### Просмотр деталей платежа

1. Администратор выбирает платеж из списка
2. Видит:
   - ID платежа
   - Пользователь (Telegram username)
   - Срок подписки (дни)
   - Количество устройств
   - Сумма к оплате
   - Код заявки (`reference_code`)
   - **Ожидаемый комментарий к переводу** (`payment_comment`)
   - Статус платежа
   - Скриншот подтверждения (если загружен)

### Одобрение платежа

1. Администратор нажимает "✅ Проверить и одобрить"
2. Система показывает ожидаемый комментарий
3. Администратор может:
   - Ввести комментарий из скриншота для проверки
   - Одобрить с предустановленным комментарием (если совпадает)
4. Система проверяет:
   - **Совпадение `payment_comment`** (строго обязательно)
   - Наличие `proof_file_id`
   - Если проверка не прошла - ошибка, платеж не одобряется
5. При успешной проверке:
   - Создается/продлевается подписка
   - Пользователь получает уведомление
   - Платеж помечается как `approved`

### Отклонение платежа

1. Администратор нажимает "❌ Отклонить"
2. Указывает причину отклонения
3. Платеж помечается как `rejected`
4. Пользователь получает уведомление с причиной

## Жизненный цикл подписки

### Статусы подписки

- **active** - активная подписка
- **expiring** - за 3 дня до окончания (уведомление отправлено)
- **paused** - подписка закончилась, grace period (3 дня)
- **expired** - подписка полностью истекла, устройства будут отозваны

### Автоматические действия (Scheduler)

**Ежедневно в полночь:**

1. **Обновление статусов подписок:**
   - `active` → `expiring` (за 3 дня до окончания)
   - `expiring` → `paused` (при `ends_at`)
   - `paused` → `expired` (при `grace_period_ends_at`)

2. **Отправка уведомлений:**
   - За 3 дня до окончания: "Подписка скоро истечет"
   - При переходе в `paused`: "Подписка приостановлена, у вас 3 дня для продления"

3. **Отзыв устройств:**
   - Через 30 дней после `grace_period_ends_at`: удаление peer'ов из WireGuard
   - Данные устройств сохраняются в БД еще 30 дней для восстановления

## Установка

### Требования

- Go 1.16+
- SQLite3
- WireGuard и wireguard-tools (должны быть установлены на том же сервере, где запускается бот)
- Telegram Bot Token (от @BotFather)

### Шаг 1: Клонирование репозитория

```bash
git clone <repository-url>
cd wireguard-telegram-bot-dev
```

### Шаг 2: Установка зависимостей

```bash
go mod download
```

### Шаг 3: Настройка WireGuard

1. Установите WireGuard и wireguard-tools на сервере:
   ```bash
   # Ubuntu/Debian
   sudo apt update
   sudo apt install wireguard wireguard-tools

   # CentOS/RHEL
   sudo yum install epel-release
   sudo yum install wireguard-tools
   ```

2. Создайте серверный конфиг (например, `/etc/wireguard/wg1.conf`):
   ```bash
   sudo nano /etc/wireguard/wg1.conf
   ```

3. Пример конфигурации:
   ```
   [Interface]
   Address = 10.66.66.1/24
   ListenPort = 51820
   PrivateKey = <server_private_key>
   SaveConfig = true
   ```

4. Запустите WireGuard интерфейс:
   ```bash
   sudo wg-quick up wg1
   ```

5. Проверьте, что интерфейс активен:
   ```bash
   sudo wg show wg1
   ```

**Важно:**
- Интерфейс `wg1` используется только Telegram-ботом
- Интерфейс `wg0` не затрагивается и может существовать параллельно

### Шаг 4: Настройка переменных окружения

```bash
cp .env.example .env
# Отредактируйте .env файл
```

Обязательные переменные:
- `TELEGRAM_APITOKEN` - токен бота от @BotFather
- `STATIC_QR_CODE` - статический QR-код для оплаты (текст или URL)
- `WIREGUARD_INTERFACE` - имя интерфейса WireGuard (например, `wg1`)
- `SERVER_ENDPOINT` - внешний IP:порт сервера (например, `123.45.67.89:51820`)
- `DNS_IPS` - DNS серверы через запятую (например, `8.8.8.8,8.8.4.4`)

Опциональные:
- `ADMIN_USERNAMES` - Telegram username'ы администраторов через запятую
- `DATABASE_DSN` - путь к SQLite файлу (по умолчанию `bot.db`)
- `DEV_MODE` - `true` для тестирования без реального WireGuard (использует DevProvisioner)

**Пример .env:**
```bash
# Telegram
TELEGRAM_APITOKEN=your_bot_token
ADMIN_USERNAMES=admin1,admin2

# WireGuard
WIREGUARD_INTERFACE=wg1
SERVER_ENDPOINT=123.45.67.89:51820
DNS_IPS=8.8.8.8,8.8.4.4

# Database
DATABASE_DSN=bot.db

# Payments
STATIC_QR_CODE=your_static_qr_code

# Development (optional)
DEV_MODE=false
```

### Шаг 5: Запуск

```bash
# Обычный запуск
go run cmd/bot/main.go

# Или соберите бинарник
go build -o wireguard-bot cmd/bot/main.go
sudo ./wireguard-bot
```

**Важно:** Для работы с WireGuard интерфейсом требуются права root (или CAP_NET_ADMIN).

## Тестовый сценарий

### Проверка базовой функциональности

1. **Создание пользователя:**
   ```
   /start
   ```
   - Пользователь должен быть создан в БД

2. **Создание платежа:**
   ```
   /menu → "Оплата/Продление" → 30 дней → 1 устройство
   ```
   - Должен быть создан payment со статусом `created`
   - Должен быть показан статический QR
   - Должен быть показан `reference_code`
   - Должен быть показан `payment_comment` с предупреждением

3. **Загрузка proof:**
   ```
   /payment → загрузить фото/документ
   ```
   - Payment должен перейти в статус `pending_review`
   - Должно быть прикреплено `proof_file_id`

4. **Admin approval (от админа):**
   ```
   /admin → выбрать платеж → "✅ Проверить и одобрить"
   ```
   - Ввести правильный `payment_comment`
   - Платеж должен быть одобрен
   - Подписка должна быть создана

5. **Создание устройства:**
   ```
   /newkeys
   ```
   - Должен быть проверен доступ (active subscription)
   - Должен быть создан peer в WireGuard
   - Должен быть выделен IP адрес
   - Должен быть возвращен конфиг и QR

### Проверка отклонения платежа

1. Создать платеж с неправильным комментарием
2. Администратор пытается одобрить с неправильным комментарием
3. Система должна вернуть ошибку
4. Платеж должен остаться в статусе `pending_review`

### Проверка лимита устройств

1. Создать подписку на 2 устройства
2. Создать 2 устройства через `/newkeys`
3. Попытка создать 3-е устройство должна вернуть ошибку "лимит устройств достигнут"

## Важные ограничения

### ⚠️ Критически важно

1. **Один статический QR-код:**
   - Одинаковый для всех пользователей
   - Не содержит метаданных
   - Настраивается через `STATIC_QR_CODE`

2. **Ручное одобрение платежей:**
   - Все платежи требуют admin approval
   - Автоматическая активация **запрещена**
   - Scheduler НЕ может активировать подписки

3. **Обязательный payment comment:**
   - Каждый платеж получает уникальный нейтральный комментарий
   - Комментарий генерируется автоматически (2-3 русских слова + суффикс)
   - Пользователь ОБЯЗАН указать этот комментарий при переводе
   - Платеж без правильного комментария **НЕ будет одобрен**

4. **Запрет provisioning без подписки:**
   - `/newkeys` и `/pubkey` доступны только при активной подписке
   - Проверка через `access.CanProvisionDevice()`
   - Лимит устройств строго соблюдается

### Дополнительные правила

- **IP выделение:** атомарное через DB транзакцию, без гонок
- **Grace period:** 3 дня после окончания подписки
- **Data retention:** устройства сохраняются 30 дней после expire
- **Subscription extension:** продлевается от текущей даты окончания
- **Price calculation:** `device_count * 100 RUB * multiplier` (30=1.0, 90=0.95, 180=0.90)

## Структура проекта

```
.
├── cmd/
│   └── bot/
│       └── main.go              # Точка входа
├── internal/
│   ├── telegram/                # Telegram бот (handlers, keyboards, commands)
│   ├── storage/                 # БД (models, migrations, repository)
│   ├── billing/                 # Платежи и подписки (billing, comment)
│   ├── access/                  # Проверка прав доступа
│   ├── scheduler/               # Фоновые задачи
│   ├── provisioning/            # Абстракция provisioning (interface, local)
│   └── wireguard/               # Обертка над Provisioner (interface, dev)
└── README.md
```

## Технические детали

### База данных

**SQLite:**
- Таблицы: `users`, `payments`, `subscriptions`, `devices`
- Миграции выполняются автоматически при старте
- Транзакции для атомарности IP выделения

### Provisioning

**LocalProvisioner (production):**
- Управление через `wgctrl` (локальный WireGuard интерфейс на том же сервере)
- Атомарное выделение IP через DB транзакцию
- Автоматическая генерация ключей и конфигов
- Все peers и IP адреса управляются локально

**DevProvisioner (testing):**
- Мок-реализация для разработки и тестирования
- Не требует реального WireGuard интерфейса
- Используется при `DEV_MODE=true`

**Переключение режимов:**
- `DEV_MODE=true` → DevProvisioner (тестирование, мок)
- иначе → LocalProvisioner (production, локальный WireGuard)

### Безопасность

- Все SQL-запросы используют prepared statements
- Транзакции для критичных операций
- Проверка прав доступа на каждом шаге
- Admin-only команды защищены проверкой `isAdmin()`

## Troubleshooting

### Бот не запускается

- Проверьте `TELEGRAM_APITOKEN`
- Проверьте права доступа к WireGuard интерфейсу (нужен root)
- Проверьте `WIREGUARD_INTERFACE` - интерфейс должен существовать

### Платежи не одобряются

- Убедитесь, что `payment_comment` совпадает точно (case-sensitive)
- Проверьте, что proof загружен
- Проверьте логи бота

### Устройства не создаются

- Проверьте активность подписки через `/menu`
- Проверьте лимит устройств
- Проверьте логи WireGuard: `sudo wg show`

## Лицензия

[Указать лицензию, если есть]

## Авторы

[Указать авторов]
